# 2020_Search Algorithm Seminar

#### 이 깃의 목적
- 탐색 알고리즘에 대한 공부 및 발표

#### 참여자
* mobileX, IVIS 인원(발표:윤소정)
- - - - 
### 목차
 * (1) 탐색이란
 * (2) 정렬되지 않은 배열에서의 탐색 (순차 탐색)
 * (3) 정렬된 배열에서의 탐색 (이진 탐색)
 * (4) 이진 탐색 트리
 * (5) AVL 트리 _균형 잡는 나무 검색(Balanced search tree)
 * (6) 2-3 트리 _균형 잡는 나무 검색(Balanced search tree)
 * (7) 2-3-4 트리 _균형 잡는 나무 검색(Balanced search tree)
 * (8) 그래프의 탐색 
 * (8.1) 깊이 우선 탐색(DFS: depth first search)
 * (8.2) 너비 우선 탐색(BFS: breath first search)
- - - -
#### 1. 탐색이란?
* : 기본적으로 여러 개의 자료 중에서 원하는 자료를 찾는 작업
* 사용되는 자료구조: 배열, 연결 리스트, 트리, 그래프 등 (가장 기초적인 방법이 배열을 사용하는 것!)
* 탐색의 단위: 항목(숫자, 구조체 등)
* 탐색키(search key): 항목과 항목을 구별시켜줌

* <b>탐색이란 탐색키와 데이터로 이루어진 여러 항목 중에서 원하는 탐색키를 가지고 있는 항목을 찾는 것!!!</b>
- - - -
#### 2. 정렬되지 않은 배열에서의 탐색(순차 탐색) 
 
 <b>순차 탐색?</b>
* 가장 간단하고 직접적인 탐색 방법
* 정렬되지 않은 배열의 항목들을 처음부터 마지막까지 하나씩 검사하여 원하는 항목을 찾아가는 방법
* 탐색에 성공하면 그 항목이 발견된 위치를 반환, 그렇지 않으면 -1을 반환
 
 <b>개선된 순차 탐색?</b>
* 리스트의 끝을 테스트하는 비교 연산을 줄이기 위해 리스트의 끝에 찾는 키값을 저장, 반복문 탈출 조건을 키값을 찾을 때까지로 설정
* 비교 연산의 수를 반으로 줄일 수 있어 탐색 성능을 향상시킴
* i 값이 리스트의 끝에 도달하였는지를 비교하지 않아도 됨(탐색이 성공 시 바로 반복문을 종료할 수 있음)
- - - -
#### 3. 정렬된 배열에서의 탐색(이진 탐색) 

 <b>이진 탐색?</b>
* 배열이 많은 항목을 가지는 경우에 순차 탐색은 비효율적
* 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지 알아냄 
 
  → 탐색의 범위를 반으로 줄임
* 배열이 반드시 정렬되어 있어야 해서 데이터의 삽입, 삭제가 빈번할 경우 부적합 (고정된 데이터에 대한 탐색에 적합)

 <b>순환 호출 사용(재귀 호출)</b>
* 순환 호출을 끝내는 코드가 들어가야 함
  (이 경우, 탐색 범위가 1보다 작으면 즉 탐색해야 할 항목이 없는 경우 순환 호출을 하지 않음)

 <b>반복 사용(반복문 사용)</b>
- - - -
#### 4. 이진 탐색 트리

 <b>이진 탐색 트리?</b>
* 이진 탐색과 같은 원리에 의한 탐색구조
* 이진 탐색은 자료들이 배열에 저장되어 있음  
  → 삽입과 삭제가 힘듦
* 비교적 빠른 시간에 삽입과 삭제를 할 수 있는 구조 → 삽입, 삭제가 빈번할 경우 이진 탐색 트리를 사용!
* 하지만! 균형 트리일 경우 효율적( 경사 트리일 경우 탐색시간이 순차 탐색과 같아 비효율적)
 - - - -
#### 5. 균형 잡는 나무 검색(Balanced search tree) - AVL 트리
 
 <b>AVL 트리?</b>
* 각 노드에서 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이 차이가 1이하인 이진 탐색 트리
* 트리가 비균형 상태가 되면 스스로 노드들을 재배치하여 균형 상태로 만듦
* 균형 인수 = 왼쪽 서브 트리의 높이 - 오른쪽 서브 트리의 높이
* 모든 노드의 균형 인수가 +1, -1 이하 일 때 AVL 트리

<b>AVL 트리의 삽입</b>
*  노드의 회전을 통해 균형을 맞춤
* LL 타입, LR 타입, RR 타입, RL 타입
 - - - -
#### 6. 균형 잡는 나무 검색(Balanced search tree) - 2-3 트리
 
 <b>2-3 트리?</b>
* 차수가 2 또는 3을 가지는 트리
* AVL 트리보다 삽입, 삭제가 쉬움
* 하나의 노드가 2개 또는 3개의 자식 노드를 가짐
- - - -
#### 7. 균형 잡는 나무 검색(Balanced search tree) - 2-3-4 트리
 
 <b>2-3-4 트리?</b>
* 하나의 노드가 4개의 자식까지 가질 수 있도록 2-3 트리를 확장한 것
* 3개의 데이터를 가짐
- - - -
#### 8.1. 그래프의 탐색 - 깊이 우선 탐색(DFS)

 <b>그래프?</b>
* 객체 사이의 연결 관계를 표현할 수 있는 자료구조
* 정점(노드): 여러 가지 특성을 가질 수 있는 객체
* 간선(링크): 정점들 간의 관계

<b>깊이 우선 탐색?</b>
* 트리를 탐색할 때 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행
* 진행: 시작 정점에서 출발 → 인접한 정점들 중 아직 방문하지 않음 정점 선택 → 그런 정점이 없다면 탐색 종료
                    → 방문하지 않은 정점이 있다면 이 정점을 시장 정점으로 하여 깊이 우선 탐색을 다시 시작
                    → 방문 안 된 정점이 없다면 다시 처음 시작 정점들 중 방문 안 된 정점을 찾음 
* 자기 자신을 다시 호출하는 순환 알고리즘의 형태
* 순환 호출(인접 리스트, 인접 행렬), 명시적 스택 이용 
- - - -
#### 8.2. 그래프의 탐색 - 너비 우선 탐색(BFS) 
 
 <b>너비 우선 탐색?</b>
* 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문
* 가까운 거리에 있는 정점들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(queue) 필요
* 큐에서 정점을 꺼내 정점을 방문하고 인접 정접들을 큐에 추가, 큐가 소진될 때까지 동일한 코드 반복
* 인접 리스트, 인접 행렬 이용
- - - -

